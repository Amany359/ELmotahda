"use strict";(self.webpackChunkcheckout_web=self.webpackChunkcheckout_web||[]).push([[661],{2879:(e,n,t)=>{var o=t(778),r=t(4987);class s extends Error{constructor(e,n){super(`GraphQL fetch failed with network failure or prevented the request from completing: ${n.message}. headers: ${JSON.stringify(Object.fromEntries(e.entries()))}`),this.headers=e,this.error=n,this.name="AddressValidatorGraphQLFetchNetworkError"}}class a extends Error{constructor(e,n){super(`GraphQL fetch failed with status: ${e}, response: ${n}`),this.status=e,this.response=n,this.name="AddressValidatorHttpError"}}const i={"Content-Type":"application/json",Accept:"application/json"},d="https://atlas.shopifysvc.com/graphql",c="elasticsearch",l="google",u=new Map([["ELASTICSEARCH_AUTOCOMPLETE",c],["GOOGLE_PLACE_AUTOCOMPLETE",l]]);class p extends Error{constructor(...e){super(...e),this.name="AutocompletePredictionError"}}const h=async(e,n)=>{const t={addressId:e,locale:n.locale,sessionToken:n.requestToken,adapterOverride:u.get(n.completionService),extendedFields:n.extendedFields},o=await fetch(d,{method:"POST",headers:{"Content-Type":"application/json","X-Shop-Id":n.shopId,"X-Client-Request-Id":n.sourceId},body:JSON.stringify({query:"\n  query address($addressId: String!, $locale: String!, $sessionToken: String!, $adapterOverride: String, $extendedFields: Boolean = false) {\n    address(id: $addressId, locale: $locale, sessionToken: $sessionToken, adapterOverride: $adapterOverride, extendedFields: $extendedFields) {\n      address1\n      address2\n      city\n      country\n      countryCode\n      province\n      provinceCode\n      zip\n      latitude\n      longitude\n    }\n  }\n",variables:t})}),{data:{address:r}}=await o.json(),{address1:s,address2:a,city:i,countryCode:c,provinceCode:l,zip:p,latitude:h,longitude:y}=r,g={latitude:h,longitude:y};return{postalCode:p,city:i,address1:s,address2:a,countryCode:c,zoneCode:l,coordinates:g.latitude&&g.longitude?g:void 0}},y=async(e,n,t)=>{const o={query:e,countryCode:n.countryCode,location:n.location,locale:n.locale,sessionToken:n.requestToken};[c,l].includes(String(t))&&(o.adapterOverride=t);const s=(0,r.tB)(),a=await fetch(d,{method:"POST",headers:{"Content-Type":"application/json","X-Shop-Id":n.shopId,"X-Client-Request-Id":n.sourceId},body:JSON.stringify({query:"\n  query predictions($query: String, $countryCode: AutocompleteSupportedCountry!, $locale: String!, $location: LocationInput, $sessionToken: String!, $adapterOverride: String) {\n    predictions(query: $query, countryCode: $countryCode, locale: $locale, location: $location, sessionToken: $sessionToken, adapterOverride: $adapterOverride) {\n      addressId\n      description\n      completionService\n      matchedSubstrings {\n        length\n        offset\n      }\n    }\n  }\n",variables:o})}),i=(0,r.tB)(),u=await a.json();if(!u.data)throw new p(`No data returned from autocomplete query ${JSON.stringify(u)}`);return{data:u.data.predictions,duration:{start:s,end:i}}},g=new class{constructor({validationEndpoint:e}){this.validationEndpoint=void 0,this.validationEndpoint=e}async validate({address:e,locale:n,matchingStrategy:t},o={}){const r=new Headers({...i,...o.overrideHeaders}),d=await fetch(this.validationEndpoint,{method:"POST",headers:r,body:JSON.stringify({query:"\nquery validation($address: AddressInput!, $locale: String!, $matchingStrategy: MatchingStrategy) {\n  validation(address: $address, locale: $locale, matchingStrategy: $matchingStrategy) {\n    validationScope\n    locale\n    fields {\n      name\n      value\n    }\n    concerns {\n      fieldNames\n      code\n      type\n      typeLevel\n      suggestionIds\n      message\n    }\n    id\n    suggestions {\n      id\n      address1\n      streetName\n      streetNumber\n      address2\n      line2\n      neighborhood\n      city\n      zip\n      provinceCode\n      province\n      countryCode\n    }\n  }\n}\n",operationName:"validation",variables:{address:e,locale:n,matchingStrategy:t}})}).catch((e=>e));if(d instanceof Error)throw new s(r,d);if(!d.ok)throw new a(d.status,await d.text());const{data:c,errors:l}=await d.json();return{data:c.validation,errors:l}}}({validationEndpoint:d}),v=async(e,n,t,o)=>{const r={"X-Shop-Id":o?.shopId||"","X-Client-Request-Id":o?.sourceId||""};return g.validate({address:e,locale:n,matchingStrategy:t},{overrideHeaders:r})},f=async(e,n)=>{const t=await async function(e){return fetch(d,{method:"POST",headers:{"Content-Type":"application/json","X-Shop-Id":n?.shopId??"","X-Client-Request-Id":n?.sourceId??""},body:JSON.stringify({query:"\n  query countries($locale: SupportedLocale!) {\n    countries(locale: $locale) {\n      name\n      code\n      phoneNumberPrefix\n    }\n  }\n",variables:{locale:e.replace(/-/,"_").toUpperCase()}})})}(e),o=await t.json(),{data:r}=o;if(!r)throw new p(`No data returned from fetch countries with phone number prefix query ${JSON.stringify(o)}`);return r.countries};"undefined"!=typeof window&&(0,o.UD)({addEventListener:window.addEventListener.bind(window),removeEventListener:window.removeEventListener.bind(window),postMessage(e,n){window.parent.postMessage(e,"*",n)}},{callable:["search","fetchAddress","validation","fetchCountriesWithPhoneNumberPrefix"]}).expose({search:y,fetchAddress:h,validation:v,fetchCountriesWithPhoneNumberPrefix:f})}},e=>{e.O(0,[778,987],(()=>(2879,e(e.s=2879)))),e.O()}]);